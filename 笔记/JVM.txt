jvm 垃圾收集器:
1）Serial收集器：
针对新生代；
	采用复制算法；
	单线程收集；
	进行垃圾收集时，必须暂停所有工作线程，直到完成；            
	即会"Stop The World"；
应用场景:
	依然是HotSpot在Client模式下默认的新生代收集器；
	也有优于其他收集器的地方：
	简单高效（与其他收集器的单线程相比）；
	对于限定单个CPU的环境来说，Serial收集器没有线程交互（切换）开销，可以获得最高的单线程收集效率；
	在用户的桌面应用场景中，可用内存一般不大（几十M至一两百M），可以在较短时间内完成垃圾收集（几十MS至一百多MS）,只要不频繁发生，这是可以接受的
2)ParNew收集器:
	ParNew垃圾收集器是Serial收集器的多线程版本。
特点
	除了多线程外，其余的行为、特点和Serial收集器一样；
	如Serial收集器可用控制参数、收集算法、Stop The World、内存分配规则、回收策略等；
	两个收集器共用了不少代码；
应用场景
      在Server模式下，ParNew收集器是一个非常重要的收集器，因为除Serial外，目前只有它能与CMS收集器配合工作；
      但在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销。
3)parallel收集器:
	和ParNew收集器类似，是一个新生代收集器。使用复制算法的并行多线程收集器。
	采用多线程来通过扫描并压缩堆
	特点：停顿时间短，回收效率高，对吞吐量要求高。
	适用场景：大型应用，科学计算，大规模数据采集等。
通过JVM参数 XX:+USeParNewGC 打开并发标记扫描垃圾回收器。
4)CMS收集器
	采用“标记-清除”算法实现，使用多线程的算法去扫描堆，对发现未使用的对象进行回收。
	（1）初始标记
	（2）并发标记
	（3）并发预处理
	（4）重新标记
	（5）并发清除
	（6）并发重置
	特点：响应时间优先，减少垃圾收集停顿时间
	适应场景：服务器、电信领域等。
	通过JVM参数 -XX:+UseConcMarkSweepGC设置
5)G1收集器
	在G1中，堆被划分成 许多个连续的区域(region)。采用G1算法进行回收，吸收了CMS收集器特点。
	特点：支持很大的堆，高吞吐量
	? --支持多CPU和垃圾回收线程
	? --在主线程暂停的情况下，使用并行收集
	? --在主线程运行的情况下，使用并发收集
	实时目标：可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收
	通过JVM参数 CXX:+UseG1GC 使用G1垃圾回收器
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

