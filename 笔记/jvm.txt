jvm 虚拟机
1.程序计数器:
可看做当前线程所执行的字节码的行号指示器.
字节码解释器在工作是就是通过改变这个计数器的值来选去下一条需要执行的字节码命令
虚拟机多线程是通过线程轮流切换并分配CPU执行时间的方式实现的,为了线程切换后能恢复到正确的执行位置每个 线程都有一个独立的线程计数器(线程私有)
如果线程执行java代码则记录正确执行的虚拟机字节码指令的地址,如果是natvie方法则计数器为空

2.虚拟机栈
是线程私有的生命周期与线程相同.虚拟机栈描述的是java方法执行的内存模型,用于存储变量表,操作栈,动态链接,方法出口等信息(每个方法被执行时都会创建一个栈帧)
我们说的虚拟机栈,也可以说是局部变量表一部分,局部变量表存放基本类型,对象引用和returnAddress类型(返回当前调用函数返回的地址，即函数吓一跳指令地址)
内存所需空间在编译期间完成分配
如果线程请求栈深度大圩虚拟机允许深度 抛出StackOverflowError异常,如果虚拟机展可扩展当扩展无法申请到足够空间则抛出OutOfMemoryError异常

3.本地方法栈
虚拟机栈是执行java方法的服务,而本地方法栈则是为虚拟机使用的native方法服务

4 java堆
所有线程共享,虚拟机启动时市创建,存放实例对象
Java堆可以处于物理内存上不连续的内存空间

5 方法区
各线程共享区域存储已被虚拟机加载的类信息,常量静态变量,即时编译器编译后的代码数据
在jdk1.8中，永久代已经不存在，存储的类信息、编译后的代码数据等已经移动到了元空间（MetaSpace）中，元空间并没有处于堆内存上，而是直接占用的本地内存（NativeMemory）

6.运行时常量池
用于存放编译器生成的各种自变量和符号引用在类加载后存放到运行时常量池
在JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace) 

















