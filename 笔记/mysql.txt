Mysql 查询执行过程
 1.语法分析阶段
	将sql语法经过词法和语法分析后转化为一个查询树 传给优化器,并对sql表达的语义进行检查
 2.生成逻辑查询执行计划
	优化器在查询树种遍历每个关系,确定关系是否是常量,每个关系查询是否能用到索引,运用关系代数和启发式规则进行逻辑上的优化
	(关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。 
  	任何一种运算都是将一定的运算符作用于一定的运算对象上，得到预期的结果。所以运算对象、运算符、运算结果是运算的三大要素。)
 3.生成物理查询执行计划
	优化器对各个链接的表进行排序,然后求解多连接的最优路径,对每个关系尽量利用索引计算代价找出最小路径进行保存
 4.执行查询执行计划
	吧查询计划传到执行器进行执行
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Mysql 查询语句执行主要过程
	sql语句输入变为语法查询树
	查询预处理,优化相关内容主要是子查询优化
	语法书变为逻辑关系查询树,进而变成物理查询执行计划,跳出最优
	依据最优查询执行计划的到查询结果
mysql主要的类和数据结构

mysql查询优化器的主要数据结构包含4个方面:
	1.查询树
	2.查询基本对象
	3.连接相关的最像与执行计划
	4.代价估算
查询树 : 累的实例保存了一条sql语句被分解后的句子内容
基本对象: 和查询优化相关的有 关系 索引 链接表 等
	(关系<表>)存放查询优化阶段需要的信息也有其他阶段用到的信息
	(索引) 定义了索引的类型和索引的关键信息 通过枚举定义了索引类 :主键索引 唯一索引 多重索引 全文索引 空间索引 外检索引
	索引算法 : B-tree算法 (默认)  R-tree算法,用于空间搜索   HASH算法 ,用于堆表索引  全文索引 用于MYisan存储引擎的表
连接相关的最像与执行计划 : mysql查询优化相关的链接对象主要有连接类(join),约束条件(Item) ,位置 等
普通索引：最基本的索引，没有任何限制
唯一索引：与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值。
主键索引：它 是一种特殊的唯一索引，不允许有空值。 
全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间。
组合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
什么是视图
      视图是一种虚拟存在的表,对于使用使徒的用户来说基本上是透明的.视图并不在数据库中实际存在,行和列数据来自定义视图的查询中使用的表,并且是在使用视图时动态生成.
视图相对于普通表优势:
       简单 :使用视图的用户完全不需要关心后面对应的表结构,关联条件和筛选条件.对用户来说已经是过滤好的复合条件的结果集
       安全 :使用视图的用户只能访问他们被允许查询的结果,对标的权限并不能限制到某个行某个列,但是通过视图就可以.
       数据独立:一旦视图的结构确定了,可以屏蔽表结构变化对用户的影响,原表增加列对视图没有影响原表修改列名,则可以通过修改视图来解决,对方问者不会产生影响
什么是存储过程核函数:
      存储过程和函数是事先经过编译并储存在数据库中的一点sql语句的集合,调用存储过程和函数可以简化应用开发人员的额很多工作,减少数据在数据库和用用服务器之间的传输.
提高数据处理效率有好处

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。
Read Uncommitted（读取未提交内容）

       在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。
Read Committed（读取提交内容）

       这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读
	（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。
Repeatable Read（可重读）

       这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。
 简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。
InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

Serializable（可串行化） 
       这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
       只要操作产生了锁，就不允许其他事务读取和修改！
         这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：
         脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
         不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
         幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，
         就会发现有几列数据是它先前所没有的。
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 
脏读 :一个事务读到了另一个事务的未提交的数据 

不可重复读 :一个事务读到了另一个事务已经提交的 update 的数据导致多次查询结果不一致. 

虚幻读 :一个事务读到了另一个事务已经提交的 insert 的数据导致多次查询结果不一致.


解决读问题:
 
未提交读（read uncommited） :脏读，不可重复读，虚读都有可能发生

已提交读 （read commited）:避免脏读。但是不可重复读和虚读有可能发生 

可重复读 （repeatable read） :避免脏读和不可重复读.但是虚读有可能发生. 

串行化的 （serializable） :避免以上所有读问题. 
Mysql 默认:可重复读 
Oracle 默认:读已提交

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
事务特性（4种）: 

原子性 （atomicity）:强调事务的不可分割. 

一致性 （consistency）:事务的执行的前后数据的完整性保持一致. 

隔离性 （isolation）:一个事务执行的过程中,不应该受到其他事务的干扰 

持久性（durability） :事务一旦结束,数据就持久到数据库

如果不考虑隔离性引发安全性问题:
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

sql 优化 
通过show status like 'Com_%' 显示当前session中所有统计参数的值
定位执行效率低的sql   
通过explain 分析低效sql
select_type : 表示select 的类型 

type = all 全表扫描
type = index 索引全表扫描 ,mysql遍历整个索引来查询匹配
type = range 索引范围扫描 常见于 < , > ,<=, >= ,between 操作
type = ref 使用非唯一索引扫描或唯一索引的前缀扫描
type = eq_ref 类似ref 区别在于使用唯一索引
type = const/system 单表中最多有一行匹配
type = null mysql 不用锁音访问或者索引 ,直接就能够得到结果

explain extended 命令 ,
通过 加上 show warnings 能看到sql真正被执行之前优化器做了哪些改写
SHOW WARNINGS 查看mysql优化器对sql做了哪些优化

通过 show profile 分析sql

select @@have_filing  查看当前数据库是否支持
默认profiling 是关闭的 可以通过 set语句session 级别开启profiling
SHOW VARIABLES LIKE 'profil%'
SET profiling=ON;
SHOW PROFILE FOR QUERY 228 查看 耗时 问题

mysql 中能使用索引的经典场景
1)匹配全职
2)匹配指的范围查询
3)匹配最左前段
4)仅仅对索引进行查询
5)匹配列前缀
6)能够实现索引匹配部分精确而其他部分进行范围匹配
7)如果列名是索引
 
mysql 中存在索引但不能使用索引的场景
1)以%开头的like查询不能使用(可以用全文索引)
2)数据类型出现隐士转换的时候不能
3)复合索引的情况下,假如查询条件不包含索引列最左边部分
4)如果mysql估计使用索引比全表扫描更慢则不使用
5)用or分割开的条件,如果or前面的条件中的列有索引,而后面的列没有索引,那么涉及的索引都不会被使用
因为or后面没有索引所以就没必要多一次索引扫描

定期分析表和检查表
分析表的语法如下:
ANALYZE TABLE  table_name

OPTIMIZE TABLE table_name  如果一个表经常修改 则可以使用  OPTIMIZE TABLE 命令来进行表优化 , 这个命令可以将表的空间碎片进行合并 并且可以消除由于删除
或者更新造成的空间浪费 但是 它 只对Myisam ,bdb 和 innodb 表起作用

优化insert 
如果同时插入多行建议尽量使用多个值的 语句 这种方式大大降低客户端与数据库之间的链接关闭等消耗
如果从不同的客户插入很多行 可以使用 insert delayed 语句得到更高的速度 delayed  的含义是 让insert 马上执行 其实数据都被放到内存中并没有写入到磁盘
当 从 一个文本文件中装载一个 ,使用load data infile 通常比 insert 快 20 倍

优化 order by 
mysq中有2种排序方式
第一种通过有序索引顺序扫描直接返回有序数据 
第二种是通过返回数据进行排序,也就是通常说的filesort排序,所有不是通过说因直接返回结果的排序都叫filesort. filesort 并不代表通过磁盘文件进行排序
filesort 是通过相应的算法排序,将取得的数据在sort_buffer_size系统变量设置的内存排序区进行排序,如果装载不下就会在磁盘上进行数据进行分块分别排序然后将各块合并
 sort_buffer_size是每个线程独占的
了解mysql排序方式 : 尽量减少额外的排序,通过索引直接返回有序数据,where条件和order by 使用相同的索引,并且 order by的顺序和索引顺序相同并且 orderby\ 字段都是生序或者降序

优化group by 
如果查询包含order by 单用户想要避免排序结果的消耗 则可以指定order by null 禁止排序 

优化嵌套查询
子查询可以被更有效的链接(join)代替
因为mysql不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作

mysql如何优化 or 条件
对含有or的查询子句 如果要利用索引 ,则or之间的每个 条件都必须要用到索引,没有索引考虑增加

mysql group by 的 with rollup 用于分组统计 不能 和 order by 一起用(互斥)

















































