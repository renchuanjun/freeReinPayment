1.精通 java 集合
1)collection集合
   1-a)list
        1-a-1).arraylist(完成)
        1-a-2).linkedlist(完成)
        1-a-3).vector - stack(完成)
   1-b)set
        1-b-1).SortedSett
        1-b-2).abstractSet
            1-b-2-1).hashset ---linkedhashset(完成)
            1-b-2-2).treeset
2)map集合
  2-a).abstractMap
      2-a-1).hashmap -- linkedhashmap(完成)
                ConcurrentHashMap
      2-a-2).weakhashmap
      2-a-3).weakhashmap
      2-a-4).hashtable
  2-b).sortedMap---treeMap
3)queue
4)comparable -- comparator
5)collection arrays
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
一 ) 集合
Arraylist
数据结构arrayList 底层 数据结构是Object数组 在内存中数据是连贯的
1).arraylist  主要 xtends AbstractList<E> implements List<E>, RandomAccess, Cloneable 
randomAccess 接口是一个标记接口 只要实现了这个接口 在conllections 的 binarySearch() 就会一定能执行索引查询 indexedBinarySerach()方法 否则会执行遍历查询 iteratorBinarySerach(也属于
二分法查找)Cloneable表示该对象能被克隆
2). add( 添加操作)(给定容量会大大提高添加效率)
arraylist 底层是object []  数组 的形式 存储 在 内存 中 每次扩容 
都会新生成一个数组并按照原有的数组扩容1.5倍(对应集合中存储的实例对象来说system.arraycopy执行的是浅拷贝修改原有对象的)
3)remove(删除操作)
arrayList 次删除 都会进行一次数据的拷贝操作(system.arraycopy)将后面的数据整体向前移动固定单位当数据量较多时会有一定的内存性能消耗(次删除指定非从后向前删除)

LinkedList
LinkedList是一个双向链表的，它的插入只是修改相邻元素的next和previous的引用  所以比较适合用来执行插入(非头尾顺序插入<频繁>)，删除(非头尾顺序删除<频繁>)等功能
1).linkedlis 添加操作 和 删除操作 原理 基本相同 
特有方法:添加元素，返回元素，删除并返回元素

Vector 
1)Vector的数据结构和ArrayList差不多
elementData 是"Object[]类型的数组"，它保存了添加到Vector中的元素。elementData是个动态数组，如果初始化Vector时，没指定动态数组的>大小，则使用默认大小10。
随着Vector中元素的增加，Vector的容量也会动态增长，capacityIncrement是与容量增长相关的增长系数，具体的增长方式，请参考源码分析中的ensureCapacity()函数
2)Vector和arraylist不同的是他可以自定义增长系数如果没有给定增长系数默认初始容量为10 每次增长一倍
最大区别是他是线程安全的synchronized


stack
1)拥有 Vector  相同的结构 stack  类表示后进先出（LIFO）的对象堆栈 , 它对Vector 做了5个扩展 ,它提供了push和 pop 操作 以及从栈顶获取数据的peek方法测试堆栈是否为空的方法empty
在堆栈中查找项并确定到堆栈顶距离的 search 方法.
主要 用于模拟一个堆栈，存放的信息是后进的元素先出


Set可以理解为集合，非常类似数据概念中的集合，集合三大特征：1、确定性；2、互异性；3、无序性，因此Set实现类也有类似的特征。
因为hashset集合的底层是hashmap并且hashset 的值 是 hashmap 的 key  在存储 的时候 会对 数据 进行 哈希计算 所以 在输出的时候 会进行 一定的排序
hashset 存储对象时 某些情况下 需要 从写hashcode 和 equals  来改变 他 的去重复 规则 因为 hashset 实际 上分 是 hashmap 的key  而 hashmap 在 存储时  会先进行 哈希碰撞 如果 哈希值 一样
还要通过 equals 去比较 key  是否相同 因为 引用对象 虽然 封装参数相同 但是 内存地址的引用 是不同的



hashmap
hashmap 底层的数据结构为 实际一个 是node[]每个数组的位置上放置的node对象 
在 hashmap 刚创建的时候 只是初始化了node 对象 但是node [] 的容量并未初始化 在第一次 put() 的时候进行第一次初始化 根据key 计算 hashcode 判断当前下标下是否为空
若为空 直接 将 node 对象放到 node[] 数组中 若不为空 就会 遍历 当前 节点的所有 node对象(死循环)   判断node.next 变量直到找到 next 为空 的node 对象 将节点 保存进去 若当前 遍历个数超过8个
变回办成 红黑树结构  hashmap  扩容 有两个调点 一个 是 达到阈值  
2. 当哈希碰撞的节点超过8时会进行一次扩容(且数组长度的小于64 当大于当前值 会将单项链表转成红黑树)
hashmap put()方法 流程：
1)首先会判断Node<K,V>[] 是否为空 若为空直接初始化并赋值
2)(p = tab[i = (n - 1) & hash]) == null 通过位运算判断当前节点是否为空 若为空直接赋值
3)



 -- linkedhashmap
linkedhashmap 的数据结构与hashmap 基本相同 只是 在 创建node 节点上增加了一个 Entry 数组
linkedhashmap 在查询时 分按照插入顺序 排序 和按照查询顺序排序


TreeMap

规则1、根节点必须是黑色。
规则2、任意从根到叶子的路径不包含连续的红色节点。
规则3、任意从根到叶子的路径的黑色节点总数相同。


删除元素 remove
首先查找到指定元素，进行删除
首先查找要删除的元素，大于右树，小于左树，如果没找到返回null 执行删除节点x的操作，分三种情况
如果x没有左孩子，或者没有右孩子，那么就用其右子树或者左子树替换当前节点x
如果x既有左孩子又有右孩子，且右孩子没有左子树（也就是右孩子为当前节点后继节点），
就用其右孩子替换当前节点，并将原左子树作为其左子树 
如果x既有左孩子又有右孩子，且右孩子有左子树，那么首先找到节点x的后继节点y，由于y满足第一种情况（没有左孩子），
所以用y的右孩子替换y，然后用y替换当前节点x
如果删除元素是黑色的，可能会破坏原有的红黑树的性质，所以删除后需要进行调整，x节点是其父节点的左右孩子的情况对称，每种情况分四种情况
如果兄弟节点是红色的（其父节点一定是黑色的，因为根据红黑树性质红色节点的孩子一定是黑色的），将其兄弟节点染黑，并将其父节点染红，然后以其父节点为轴进行左旋，
旋转后原兄弟节点的左孩子成为x新的兄弟节点 如果兄弟节点是黑色的且其左右子树都是黑色的（第一种情况旋转后必然到第二种情况），将其兄弟节点染为红色，
x跳到其父节点（只需要最后再将x染红，调整结束） 如果兄弟节点是黑色的且其右子树是黑色的左子树为红色，将其兄弟节点左子树染为黑色，其兄弟节点染为红色，
以其兄弟节点为轴执行右旋（执行完跳转到下一种情况） 如果兄弟节点是黑色的且其右子树是红色的，兄弟节点染为其父亲节点颜色，父节点染为黑色，兄弟节点右孩子染为黑色，
以其父节点为轴左旋，x跳转到根节点


添加更新元素 put
首先根据是否提供了比较器(comparator)来区别进行查找 如果找到相等的key（注意这里不是通过equals方法，而是compare方法，所以只有保证compare与equals方法一致，
才能保证TreeMap的插入操作与Map接口的定义一致），更新对应节点的value 如果没有找到就新建Entry，
然后根据最后一次比较结果作为查找路径的最后节点的左子树或者右子树 新插入节点可能破坏红黑树性质4与性质2，需要进行调整，且调整过程中保证不会破坏其他性质
首先当前插入节点为红色 如果其父节点也是红色，进行调整 直到性质4不再被违背后将根节点图为黑色，性质2满足，结束调整
父节点为红色时需要进行调整，调整分为三种情况，叔节点为x的parent的parent的另一个孩子，其中x节点的父节点为祖父节点的左右子树的情况与左子树的情况是对称的
- 情况一，如果x的叔节点为红色，就把父节点与叔节点都染黑，祖父节点染红，x跳转到祖父节点继续调整
- 情况二，如果叔节点是黑色的，且当前节点为其父节点的右孩子，就以其父节点为轴进行左旋，结果跳转到情况三
- 情况三，如果叔节点是黑色的，且当前节点为其父节点的左孩子，先将父节点染黑，祖父节点染红，然后进行右旋



ConcurrentHashMap

　　说明：put函数底层调用了putVal进行数据的插入，对于putVal函数的流程大体如下。
　　① 判断存储的key、value是否为空，若为空，则抛出异常，否则，进入步骤②
　　② 计算key的hash值，随后进入无限循环，该无限循环可以确保成功插入数据，若table表为空或者长度为0，则初始化table表，否则，进入步骤③
　　③ 根据key的hash值取出table表中的结点元素，若取出的结点为空（该桶为空），则使用CAS将key、value、hash值生成的结点放入桶中。否则，进入步骤④
　　④ 若该结点的的hash值为MOVED，则对该桶中的结点进行转移，否则，进入步骤⑤
　　⑤ 对桶中的第一个结点（即table表中的结点）进行加锁，对该桶进行遍历，桶中的结点的hash值与key值与给定的hash值和key值相等，则根据标识选择是否进行更新操作（用给定的value值
替换该结点的value值），若遍历完桶仍没有找到hash值与key值和指定的hash值与key值相等的结点，则直接新生一个结点并赋值为之前最后一个结点的下一个结点。进入步骤⑥
　　⑥ 若binCount值达到红黑树转化的阈值，则将桶中的结构转化为红黑树存储，最后，增加binCount的值。

实现分段锁 
1.初始化的时候 initable() 会判断 sizeCtl 属性是否小于零 如果小于0 表示 已经有线程进行初始化当前对象会调用Thread.yield(); 让出cpu
2.完成后在添加 是 会对 当前节点的桶对象进行synchronized 枷锁
 